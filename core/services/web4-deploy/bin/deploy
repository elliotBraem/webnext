#!/usr/bin/env node

const { Web3Storage } = require('web3.storage')

const CID = require('cids');
const { connect, keyStores, Account, KeyPair, transactions } = require('near-api-js');

const path = require('path');
const fs = require('fs');
const timeoutSignal = require("timeout-signal");
const fetch = require('node-fetch');

const { CarReader } = require('@ipld/car');
const { packToFs } = require('ipfs-car/pack/fs');

const { deployNEARFS } = require('../src/util/nearfs.js');

const meow = require('meow');

const cli = meow(`
    Usage:

        web4-deploy <src-directory> <destination-account.near>

    Options:

        --deployContract [contract-name]   Deploy contract to the account.
            If contract name is not provided, default contract gonna be deployed: https://github.com/vgrichina/web4-min-contract

        --nearfs                           Deploy to NEARFS instead of IPFS.
            See more details on https://github.com/vgrichina/nearfs

        --help                             Show this help message.

        --version                          Show package version.
`, {
    flags: {
        deployContract: {
            type: 'string',
        },
        nearfs: {
            type: 'boolean',
        },
        help: {
            type: 'boolean',
        },
        version: {
            type: 'boolean',
        }
    },
    allowUnknownFlags: false
});

if (cli.input.length !== 2) {
    cli.showHelp(1);
}

deploy(cli);

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function deploy(cli) {
    const WEB3_TOKEN = process.env.WEB3_TOKEN;
    const ESTUARY_TOKEN = process.env.ESTUARY_TOKEN;
    if (!WEB3_TOKEN && !ESTUARY_TOKEN && !cli.flags.nearfs) {
        console.error(`
You need to set either WEB3_TOKEN or ESTUARY_TOKEN environment variable to allow IPFS pinning.

WEB3_TOKEN environment variable needs to be set to your web3.storage API token.
See https://web3.storage/docs/how-tos/generate-api-token/ for more information.

ESTUARY_TOKEN environment variable needs to be set to your Estuary API token.
See https://docs.estuary.tech/tutorial-get-an-api-key for more information.

Or use --nearfs flag to deploy to NEARFS instead of IPFS.

`);
        process.exit(1);
    }
    const [ dir, accountId ] = cli.input;

    const NEAR_SIGNER_ACCOUNT = process.env.NEAR_SIGNER_ACCOUNT || accountId;
    const NEAR_SIGNER_KEY = process.env.NEAR_SIGNER_KEY;

    async function connectNEAR() {
        const config = require('../src/config')(process.env.NEAR_ENV || process.env.NODE_ENV);
        const keyStore = NEAR_SIGNER_KEY ? new keyStores.InMemoryKeyStore() : new keyStores.UnencryptedFileSystemKeyStore(`${process.env.HOME}/.near-credentials`);
        if (NEAR_SIGNER_KEY) {
            keyStore.setKey(config.networkId, NEAR_SIGNER_ACCOUNT, KeyPair.fromString(NEAR_SIGNER_KEY));
        }
        const near = await connect({
            ...config,
            keyStore
        })
        const account = new Account(near.connection, NEAR_SIGNER_ACCOUNT);
        return { config, keyStore, near, account };
    }

    const { config, account } = await connectNEAR();

    console.log('Packaging files into a CAR file...');
    const tmpDir = fs.mkdtempSync('web4-deploy-');
    const carFile = `${tmpDir}/deploy.car`;
    // NOTE: packToBlob seems to pack raw input string instead of files? TODO: Figure out how to avoid tmp file
    const { root } = await packToFs({ input: dir, output: carFile, wrapWithDirectory: false });
    const carBuffer = Buffer.from(fs.readFileSync(carFile));
    fs.rmSync(tmpDir, { recursive: true });

    const carReader = await CarReader.fromBytes(carBuffer);

    if (ESTUARY_TOKEN) {
        console.log('Uploading CAR file to Estuary...');
        const addCar = await fetch('https://upload.estuary.tech/content/add-car', {
            headers: {
                'Authorization': `Bearer ${ESTUARY_TOKEN}`,
            },
            method: 'POST',
            body: carBuffer
        });

        if (!addCar.ok) {
            throw new Error('Failed to upload CAR file to Estuary');
        }
    }

    if (WEB3_TOKEN) {
        console.log('Uploading CAR file to web3.storage...')
        const storage = new Web3Storage({ token: WEB3_TOKEN })
        await storage.putCar(carReader);
    }

    if (cli.flags.nearfs) {
        await deployNEARFS(account, carBuffer);
    }

    const rootCID32 = new CID(root.toString()).toV1().toString('base32');
    const cids = [];
    for await (const cid of carReader.cids()) {
        cids.push(new CID(cid.toString()).toV1().toString('base32'));
    }

    if (ESTUARY_TOKEN || WEB3_TOKEN) {
        await checkIPFSGateways(cids);
    }

    if (cli.flags.deployContract != undefined) {
        await deployContract(account, cli.flags.deployContract);
    }

    const url = `ipfs://${rootCID32}`;
    console.log('\nUpdating static url', url);

    try {
        const { transaction: { hash } } = await account.functionCall(accountId, 'web4_setStaticUrl', { url });
        console.log('Updated in transaction:', `${config.explorerUrl}/transactions/${hash}`);
    } catch (e) {
        if (e.message.includes('Cannot find contract code for account')) {
            console.log(`
Account ${account.accountId} doesn't have a contract deployed yet.
Please deploy contract first using --deploy-contract option.

Example:

    web4-deploy website/source/dir ${account.accountId} --deploy-contract ./out/main.wasm


You can use default contract as well:

    web4-deploy website/source/dir ${account.accountId} --deploy-contract

This going to deploy mimimal contract which just sets static url to the one provided.
See https://github.com/vgrichina/web4-min-contract.

            `);
            process.exit(1);
        }

        throw e;
    }

    async function checkIPFSGateways(cids) {
        const IPFS_GATEWAY_LIST = (process.env.IPFS_GATEWAY_LIST || 'cloudflare-ipfs.com').split(',');
        const IPFS_CHECK_DELAY = 15000;

        await Promise.all(IPFS_GATEWAY_LIST.map(async (gateway) => {
            const remainingCids = [...cids];
            do {
                console.log(gateway, 'remaining files', remainingCids.length);
                const cid32 = remainingCids.shift();
                const urlToCheck = `https://${gateway}/ipfs/${cid32}/`;
                console.log(`Checking ${urlToCheck}...`);
                try {
                    const res = await fetch(urlToCheck, { signal: timeoutSignal(5000) });
                    console.log(res.status, urlToCheck);
                    if (res.status == 429) {
                        console.log('Too many requests, sleeping...');
                        await sleep(IPFS_CHECK_DELAY);
                    }
                    if (!res.ok) {
                        console.log('Error while fetching', urlToCheck, res.status, res.statusText);
                        remainingCids.push(cid32);
                    }
                } catch (e) {
                    if (e.name === 'AbortError') {
                        remainingCids.splice(0, 0, cid32);
                        console.log(`${urlToCheck} timeout, retrying after extra delay...`);
                        await sleep(IPFS_CHECK_DELAY);
                    } else {
                        remainingCids.push(cid32);
                        console.error(urlToCheck, e);
                    }
                }
            } while (remainingCids.length > 0);
        }));
    }
}

async function deployContract(account, contractPath) {
    console.log('Deploying contract...');
    // NOTE: This contract is taken from https://github.com/vgrichina/web4-min-contract
    contractPath = contractPath || path.resolve(__dirname, '../data/web4-min.wasm');
    const contract = fs.readFileSync(contractPath);

    await account.deployContract(contract);
}